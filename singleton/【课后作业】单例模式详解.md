

1. 熟练掌握单例模式的常见写法:
    ```
    饿汉式：静态块单例
    懒汉式：静态内部类、双重检查锁、线程安全（加synchronized）
    注册式又称登记式：容器缓存、枚举登记（饿汉式）   
    ThreadLocal单例
    ```

2. 总结每种单例写法的优、缺点：
    ```
    饿汉式：在单例类首次加载时就创建实例
       优点：没有加任何的锁、执行效率高，绝对线程安全
       缺点：用与不用都占着空间，浪费了内存
       
    懒汉式：被外部类调用时才创建实例
       优点：节约内存空间
       缺点：不加同步的懒汉式是线程不安全的，线程安全(加synchronized)的对程序性能存在一定影响
    静态内部类懒汉式：
       优点：调用获取单例对象时才会初始化，线程安全
       
    注册式单例：
        将每一个实例都缓存到统一的容器中，使用唯一标识获取实例。   
        枚举单例：
           优点：线程安全，在jdk层面就控制避免被反射以及反序列化破坏
           缺点：可读性较低
        容器类单例：
           优点：统一容器来管理，把对象保存到map中，再根据唯一key进行获取，减低耦合
           缺点：线程不安全
           
    ThreadLocal单例：保证线程内部的全局唯一，且天生线程安全
        优点：线程间是线程安全
        缺点：但是每个线程会有自己的一份，多线程情况下会创建多个实例
    ```
   
3. 思考破坏单例模式的方式有哪些？并且归纳总结。

    ```
        反射:通过反射破坏，通过强制访问，调用构造器创造类实例
            解决：在私有构造器中进行判断
                  if(LazyHolder.LAZY != null){
                      throw new RuntimeException("不予许创建多个实例");
                  } 
    
        序列化:反序列化时导致单例破坏，在转换过程中会重新创建对象
            解决：在单例中重写readResolve方法，反序列化过程中，通过判断是否存在该方法，存在则会调用该方法，对已经new出来的对象进行覆盖；
    ```			
4. 梳理内部类的执行逻辑，并画出时序图。
    

================================================


单例模式的优点：
    在内存中只有一个实例，减少了内存开销。
    可以避免对资源的多重占用。
    设置全局访问点，严格控制访问。
    
 单例模式的缺点：
    没有接口，扩展困难
    如果要扩展单例对象，只有修改代码，没有其他途径。
    